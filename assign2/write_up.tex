\documentclass[letterpaper,10pt,serif,draftclsnofoot,onecolumn,compsoc,titlepage]{IEEEtran}

\usepackage{graphicx}                                        
\usepackage{amssymb}                                         
\usepackage{amsmath}                                         
\usepackage{amsthm}                                          
\usepackage{cite}
\usepackage{alltt}                                           
\usepackage{float}
\usepackage{color}
\usepackage{url}

\usepackage{balance}
\usepackage[TABBOTCAP, tight]{subfigure}
\usepackage{enumitem}

\usepackage{geometry}
\geometry{margin=.75in}
\usepackage{hyperref}
%\usetikzlibrary{shapes, positioning, calc}
\usepackage{caption}
\usepackage{listings}
%\usepackage[utf8]{inputenc}
%pull in the necessary preamble matter for pygments output

%% The following metadata will show up in the PDF properties
% \hypersetup{
%   colorlinks = false,
%   urlcolor = black,
%   pdfauthor = {\name},
%   pdfkeywords = {cs311 ``operating systems'' files filesystem I/O},
%   pdftitle = {CS 311 Project 1: UNIX File I/O},
%   pdfsubject = {CS 311 Project 1},
%   pdfpagemode = UseNone
% }

\parindent = 0.0 in
\parskip = 0.1 in
\title{Writing Assignment 1}
\author{Shannon Ernst, Keith Stirby, Tanner Cecchetti\\ 5 May 2017 \\ CS 444 Spring 2017 \\ Group 10-01}
\begin{document}
\maketitle
\begin{abstract}
\end{abstract}
\newpage
\tableofcontents
\newpage
\section{Purpose and Learning}
The purpose of this assignment was to explore patching the kernel with a 
new I/O scheduler, in particular the LOOK scheduler. The LOOK scheduler is 
an elevator algorithm which is based on traveling in one direction on the 
disk, looking to see if there is anything left in that direction, if there 
is not, it turns around and continues going in the opposite direction 
until nothing is left and so on. C-Look is similar only it goes to the 
top and then restarts at the bottom instead of traveling down, servicing 
requests along the way. From this assignment we learned a number of things. 
We learned primarily about search the kernel code base for things that 
were relevant to our patch. This was important as often the hardest step 
is not figuring out the solution to the problem (we all had a fairly good 
idea of what the elevator should do) but how to do it within the code 
constraints presented. We were instructed to use the noop io scheduler file 
as our guide so the first thing we had to do was figure out what was going 
on in the file and what to change. This was the longest part of the 
assignment. The next thing we learned was how to test that the system is 
working. Not surprisingly, it is fairly difficult to test things which 
are going on in the background or happening rapidly. Last we learned about 
the elevator algorithm and queues in the kernal. Though this was the main 
thrust of the assignment, it is ranked last as we definitely spent more 
time and learned more on the supporting structures. 

\section{Design Choices}
In designing our solution we had a couple decisions to make. The first was 
whether to implement LOOK or C-LOOK. The difference between the two 
approaches is LOOK requires that the list is sorted relative to the current 
position of the head on insert where C-LOOK is simply sorting in ascending 
order. From an efficiency standpoint, LOOK is the better option. What 
would need to occur in LOOK is we would have to pick a turning point for 
going from ascending to descending and vice versa. This could be 
accomplished by how we sort and insert. If a value came in that was less
than our head it would be placed after our max value but sorted relative to
all of the values after our max. If a value came in that was greater than 
our head but less than our max, then it would be sorted between the head 
and the max. If a value came in that less than our smallest number it would 
appended after our smallest number and point to the next highest if 
we were in the ascending portion of the queue. This constant switching 
and monitoring of direction can be tricky to do and will require two kinds 
of sorts. \\
For C-LOOK, it is slightly less efficient because it will go in one 
direction until it runs out of jobs and then restarts from the smallest 
number. This means the disk head will make a full pass of the disk without 
doing anything. The algorithm for implementing this a tad simpler with only 
one sort, a classic insertion sort, with the max number pointing next to 
the smallest number. The only special cases for the sort would be if 
inserting a number greater than the max or smaller than the smallest which 
would just be getting the smallest previous to point to the max and the 
max next to point to the smallest. In either case of LOOK or C-LOOK the 
dispatch stays the same, only having to follow the next pointers of the 
queue as everything is in the correct order. \\
We decided to go with the C-LOOK as it was an easier algorithm for us to 
understand from a coding perspective, despite it being slightly less 
efficient. The next design choice we had to make was how we were going 
to keep track of our queue. We used the kernel data structure for this and 
some kernel code to get access to the sector. Ultimately, we did not have 
to change much in the noop io scheduler aside from add request which simply 
required us to specify our method of inserting as we described above. 
\section{Testing}
The first indication that everything was working was the kernel boot. For 
the first few times the kernel would not compile or boot. The next thing 
we did was print the sector number being added and dispatched. This would 
just print to the screen and interrupt everything in the foreground. 
This gave us a good indication that things were happening in order but 
was generally hard to read. We finally settled on creating a python 
script which generated 25 files and one million characters in 
each. We plotted our output and saw that it was working correctly but were 
concerned that our testing wasn't rigorous enough. We decided to redo our 
script so that we created the files, shuffled their order, and randomly 
read and wrote inside the file via seek. This did confirm that we were 
testing correctly. Our graph indicates that we do jump all over the disk 
but only in regards to files not the actual sectors.   
\section{Version Control and Work Log}
Tuesday, May 2, 3:20 pm to 5:30 pm: We met as a group to begin the 
assignment. The majority of the time was spent researching and disecting
the kernel code. We did not know where to begin. We did the initial set up 
of copying the noop file and and doing the proper adjustments of sstf but 
that was about it. \\
Wednesday, May 3, 6:00 pm to 9:00 pm: We met to continue working on 
the assignment. We began by grabbing a whiteboard and breaking down the 
LOOK and C-LOOK algorithm and making a decision to go with C-LOOK. We 
then spent time wrapping our head around how queues work in the kernel 
and how to do a sort that would reflect C-LOOK and LOOK. Once we had 
determined this we began coding. We had figured out where we needed to 
adjust the code (in add request). We tested a few times and things looked 
to be working so we called it a night. \\
Thursday, May 4, 6:00 pm to 10:00 pm: We met to continue working. We were 
in the testing stage. We wrote some python scripts to generate file i/o. 
We also found a way to plot our output with python so we could see it 
graphically. We began to worry that we were not doing things correctly 
because the graph looked to clean. We adjusted our scripts and caught 
one bug that we fixed. We were still concerned so we emailed McGrath our 
data and he said it was correct.\\
Friday, May 5, 2:00 pm to 3:30 pm: We met after our demo to finish the 
code. The concurrency had been completed during recitation two and we
 checked it to make sure it was working. We implemented our patch
  and submitted. \\ 
\newpage
\end{document}
